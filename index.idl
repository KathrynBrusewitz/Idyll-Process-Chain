[meta title:"Process Node System, Chaining and Lifecycle" description:"An exploratory explanation of the process node system, chaining, and lifecycle framework." /]

[Header
  title:"Process Systems, Chains, and Lifecycles"
  subtitle:"An exploratory explanation of the architectural design of a visual framework for processes."
  author:"Kathryn Brusewitz"
  authorLink:"https://kathrynbrusewitz.github.io/" /]

## Managed Services

With IT driving all business operations, the significance of aligning managed IT services with all levels in an organization has grown to ensure meeting business goals. Businesses of all sizes and across all industries hire MSPs (Managed Service Providers) as an efficient way to stay up-to-date on technology, have access to skills and address isues related to cost, quality of service and risk.

Bound by a contractual, service-level agreement with the client, MSPs assume the management and responsibility for providing a defined set of services that meet performance and quality metrics.

Generally, MSPs provide dedicated support for IT infrastructure. Historically, services began with remote monitoring and management of servers and networks. Today, the scope of MSP services have expanded to include mobile device management, managed security, remote firewall administration and security-as-a-service, and managed print services.

Growing IT infrastructure of enterprises, increasing number of compliances, and increasing adoption rate of cloud deployment by small and medium-sized businesses, are driving the growth of the managed services market. The managed services market size is expected to grow from an estimated $152.45 billion in 2017 to $267.84 billion by 2022.

## Motivation

I work for Contuit, a four-person startup building a framework that centralizes integrations into one platform, brings MSPs together as a community, drives process maturity and enforces integrity.

The purpose of this project is to explore the concept of a process maturity framework from scratch. How do we optimize processes? What do we need to know in order to make informed decisions when updating processes? How do we visualize the execution history of a process? How should we implement versioning of processes? How do we visualize version history so we can identify what works and what does not? How do we handle the concept of sub-processes and parallel processes?

These questions motivate the need to design a visual framework encompassing the system of relationships and histories between processes and executions.

Why explore visualizations? Traditionally, engineers monitor and manage processes from a dashboard, typically viewing and acting on a host of processes in a list. This type of view stifles the evolution of processes. Processes are not always linear. As processes get more complex, depend on other integrations, and depend on even other processes and likewise is a dependency for others, managing and understanding them from a list becomes difficult.

In an effort to explain my design choices, I do not just present the visual framework, but I walk through the architectural design process * *badum-tish* * from which the framework came about. For the full list of components and their definitions, skip to the Appendix down below.

## Process

We should start by defining what a process is.

A process...

- Defines the steps to be completed
- Must have at least one step
- Must be executable itself

The most basic process is linear.

TODO: Process Component: Render a Linear Process

## Triggers and Dependencies

## Process Versioning and History

## Process Lifecycle

The following lifecycle demonstrates how updates to a process chain builds the version history of the process.

We begin by defining Process 1, implicitly initializing Process Chain 1v1.

We then define Process 2, implicitly initializing Process Chain 2v1.

We then update Process 1 so that Step 2 triggers Process Chain 2v1. This saves as Process Chain 1v2.

We then update Process 2. This saves as Process Chain 2v2.

We then update Process 1 to instead use Process Chain 2v2. This saves a Process Chain 1v3.

## Execution History

## Execution Breakdown

## Application View Flow

This section details my suggestion for designing the user experience within the framework. Beginning from the highest level of overview, the engineer drills down through components and sub-components of the process framework to reveal more specific details.

### Process System

A more accurate, but more verbose, term for this view may be "System of Process Chains". I call it a Process System for short.

The Process System lays out all the Process Chains that have ever been defined, simplified into blocks. The focus is on the relationships drawn between different versions across all Processes. Each column is a Process, listing down the version history of that process.

Visual cues can be applied to the blocks. Examples are:

- Mark deprecated (non-executable) versions by fading them or crossing them out.
- Mark Process Chains that are not meeting success criteria by shading them a different color.

This view can be enhanced by providing filter options to the user. Examples are:

- Filter out deprecated versions or available versions.
- Filter by attributes available in Process Chains, e.g. by execution metrics (engineers involved, execution frequency) and performance metrics.
- Filter for all Process Chains with a dependency on a given Process Chain.
- Filter for all Process Chains that trigger a given Process Chain.

### Process Lifecycle

The Process Lifecycle is essentially the history of the process. It allows us to compare details and metrics between versions, where each version is a Process Chain.

### Process Chain

A Process Chain is synonymous with a version of a process. It does not reveal the minute details of the steps, but rather gives a map of how steps relate to each other, both within the same process and with other processes.

From here, we can drilldown into a specific Process.

### Process

The Process shows us the steps in full detail while leaving out the relationships between steps. We leave that to the Process Chain to effectively visualize.

The Process view is the most effective visualization for engineers to carry out process executions. It is also the most adaptable to an edit view.

## Appendix

[dl]
  [dt]Process[/dt]
  [dd]Defines the steps to be completed. Must have at least one step and must be executable itself. Has two states: Enabled and Deprecated.[/dd]

  [dt]Execution[/dt]
  [dd]An instance of a process. Typically started by an engineer, by another process, or by an API call. Has three states: In-Progress, Finished (Success), Failed.[/dd]

  [dt]Step[/dt]
  [dd]Must belong to a process. Can trigger the execution of one or more other processes. Cannot trigger the execution of its own process. Can depend on the completion of one or more steps in one or more other processes[/dd]

  [dt]Process Chain[/dt]
  [dd]A version of a process. Shows how steps relate to other steps within the same process and other processes.[/dd]
[/dl]
