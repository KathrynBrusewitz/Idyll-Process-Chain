[meta title:"Process Node System, Chaining and Lifecycle" description:"An exploratory explanation of the process node system, chaining, and lifecycle framework." /]

[Header
  title:"Process Systems, Chains, and Lifecycles"
  subtitle:"An exploratory explanation of the architectural design of a visual framework for a system, chain, and lifecycle of processes."
  author:"Kathryn Brusewitz"
  authorLink:"https://kathrynbrusewitz.github.io/" /]

## Managed Services

With IT driving all business operations, the significance of aligning managed IT services with all levels in an organization has grown to ensure meeting business goals. Businesses of all sizes and across all industries hire MSPs (Managed Service Providers) as an efficient way to stay up-to-date on technology, have access to skills and address isues related to cost, quality of service and risk.

Bound by a contractual, service-level agreement with the client, MSPs assume the management and responsibility for providing a defined set of services that meet performance and quality metrics.

Generally, MSPs provide dedicated support for IT infrastructure. Historically, services began with remote monitoring and management of servers and networks. Today, the scope of MSP services have expanded to include mobile device management, managed security, remote firewall administration and security-as-a-service, and managed print services.

Growing IT infrastructure of enterprises, increasing number of compliances, and increasing adoption rate of cloud deployment by small and medium-sized businesses, are driving the growth of the managed services market. The managed services market size is expected to grow from an estimated $152.45 billion in 2017 to $267.84 billion by 2022.

## Motivation

I work for Contuit, a four-person startup building a framework that centralizes integrations into one platform, brings MSPs together as a community, drives process maturity and enforces integrity.

The purpose of this project is to explore the concept of a process maturity framework from scratch. How do we optimize processes? What do we need to know in order to make informed decisions when updating processes? How do we visualize the execution history of a process? How should we implement versioning of processes? How do we visualize version history so we can identify what works and what does not? How do we handle the concept of sub-processes and parallel processes?

These questions motivate the need to design a visual framework encompassing the system of relationships and histories between processes and executions.

Why explore visualizations? Traditionally, engineers monitor and manage processes from a dashboard, typically viewing and acting on a host of processes in a list. This type of view stifles the evolution of processes. Processes are not always linear. As processes get more complex, depend on other integrations, and depend on even other processes and likewise is a dependency for others, managing and understanding them from a list becomes difficult.

In an effort to explain my design choices, I do not just present the visual framework, but I walk through the architectural design process * *badum-tish* * from which the framework came about. For the full list of components and their definitions, skip to the Appendix down below.

## Process

We should start by defining what a process is.

A process...

- Defines the steps to be completed
- Must have at least one step
- Must be executable itself

The most basic process is linear.



## Triggers and Dependencies

## Process Versioning and History

## Process Lifecycle

The following lifecycle demonstrates how updates to a process chain builds the version history of the process.

We begin by defining Process 1, implicitly initializing Process Chain 1v1.

We then define Process 2, implicitly initializing Process Chain 2v1.

We then update Process 1 so that Step 2 triggers Process Chain 2v1. This saves as Process Chain 1v2.

We then update Process 2. This saves as Process Chain 2v2.

We then update Process 1 to instead use Process Chain 2v2. This saves a Process Chain 1v3.

## Execution History

## Execution Breakdown


## Appendix

A process...

- Defines the steps to be completed
- Must have at least one step
- Must be executable itself
- Has two states: Enabled and Deprecated

An execution...

- Is an instance of a process
- Is started by an engineer, by another process, or by an API call
- Has three states: In-Progress, Finished (Success), Failed

A step...

- Can trigger the execution of one or more other processes
- Cannot trigger the execution of its own process
- Can depend on the completion of one or more steps in one or more other processes
